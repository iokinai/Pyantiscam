import json

import requests


def generate_prompt(dialogue: list[str], call_number: int, ksv: list[str]) -> str:
    prompt = """
    Роль: Ты — AI-анализатор безопасности, специализирующийся на выявлении мошеннических и подозрительных паттернов в телефонных разговорах. Твоя задача — проанализировать предоставленный текст звонка и присвоить ему одну из трёх категорий: мошеннический, подозрительный или обычный.

    Критерии классификации:

    Мошеннический: Звонок содержит один или несколько ключевых индикаторов мошенничества:

    Прямой запрос конфиденциальных данных: просьба сообщить код из SMS, пароль, данные карты, паспорта, CVC/CVV.

    Попытка удалённого доступа: инструкции по установке приложений (AnyDesk, TeamViewer и т.д.), нажатию кнопок в меню телефона.

    Финансовые требования: прямая или замаскированная просьба о переводе денег, оплате, пополнении счета.

    Имитация официального лица: представился сотрудником банка, государственного органа (Почта России, ФОМС, ФСБ, МВД), службы безопасности, курьерской службы, техподдержки — в сочетании с одним из вышеуказанных индикаторов.

    Сценарий "Друг/Родственник": абонент не представляется, но ведёт себя как знакомый и просит срочную финансовую помощь.

    Подозрительный: Звонок вызывает настороженность, но не содержит явных мошеннических инструкций:

    Звонящий представляется официальным лицом (банк, соцслужба), но цель звонка размыта или неестественна.

    Используется давление (срочность, запугивание, излишняя настойчивость), но без прямых просьб о деньгах или кодах.

    Есть несоответствия в легенде (например, абонент опровергает базовый предлог звонка).

    Запрос общих персональных данных (ФИО, адрес) без явной необходимости.

    Обычный: Звонок не содержит признаков мошенничества или подозрительной активности:

    Деловое или личное общение без признаков обмана.

    Информационные звонки (напоминания, опросы), где личные данные не запрашиваются или запрашиваются в рамках стандартной процедуры (например, для идентификации).

    Четко идентифицируемый коммерческий или сервисный звонок без давления и запроса конфиденциальной информации.

    Инструкция:
    Проанализируй предоставленный ниже текст транскрипта телефонного звонка. Опирайся исключительно на текст. Присвой звонку одну из трёх категорий: МОШЕННИЧЕСКИЙ, ПОДОЗРИТЕЛЬНЫЙ или ОБЫЧНЫЙ.

    Формат входных данных:

    {
        // Диалог представляет собой массив фраз вида: SPEAKER_N [segment_start, segment_end]: text. Учитывай, что в номерах спикеров может быть ошибка, поэтому делай вывод в том числе исходя из контекста
        "dialogue": [string],
        // Номер звонка, просто число
        "call_number": number,
        // Если голос, похожий на голос одного или нескольких спикеров есть в базе данных известных нам мошенников, то они будут перечислены тут. Это НЕ 100% доказательство, но может добавлять вес. Пример: [SPEAKER_01, SPEAKER_00]
        "known_scammers_voice": [string]
    }

    Формат выходных данных:

    Ты должен предоставить выходные данные в виде JSON, без лишнего текста, и ПОЛНОСТЬЮ соответствовать схеме ниже

    {
        // Номер звонка, тот же что и у запроса
        "call_number": number,
        // Категория звонка
        "category": "normal" | "suspicious" | "fraudulent",
        // Общее содержание звонка
        "summary": string,
        // Риск-скор от 0 до 10. 10 - значит что звонок 100% мошеннический, а 0 - что звонок 100% чистый
        "risk_score": number,
        // Индикаторы мошенничества / подозрительные моменты (если есть)
        "indicators": [string]
        // Спикеры, являющиеся мошенниками (например, [SPEAKER_00, SPEAKER_01])
        "scammers": [string]
    }

    Входные данные:
    """ + json.dumps({
        "dialogue": dialogue,
        "call_number": call_number,
        "known_scammers_voice": ksv
    }, ensure_ascii=False)

    return prompt


def send_request(prompt, ollama_server, model: str | None = "ilyagusev/saiga_llama3"):
    OLLAMA_GENERATE_PATH = "api/generate"
    resp = requests.post(f"{ollama_server}/{OLLAMA_GENERATE_PATH}", json={
        "model": model,
        "prompt": prompt,
        "stream": False,
        "options":  {"temperature": 0}
    }, verify=False)

    try:
        res = resp.json()
        return res
    except:
        print(f"ERROR: {resp.status_code}, {resp.text}")
        return ""
